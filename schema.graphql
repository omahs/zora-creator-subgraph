type TransactionInfo @entity {
  id: ID!
  block: BigInt!
  logIndex: BigInt!
  address: Bytes!
  timestamp: BigInt!
}

type SalesConfig @entity(immutable: true) {
  id: ID!

  publicSalePrice: BigInt!
  maxSalePurchasePerAddress: BigInt!
  publicSaleStart: BigInt!
  publicSaleEnd: BigInt!
  presaleStart: BigInt!
  presaleEnd: BigInt!
  presaleMerkleRoot: Bytes!

  drop: ERC721Drop!
}

type ContractConfig @entity {
  id: ID!

  metadataRenderer: Bytes!
  editionSize: BigInt!
  royaltyBPS: BigInt!
  fundsRecipient: Bytes!

  drop: ERC721Drop!
}

type ERC721Drop @entity {
  id: ID!

  created: TransactionInfo!
  createdAt: BigInt!

  version: BigInt!

  contractURI: String

  creator: Bytes!
  owner: Bytes!
  address: Bytes!
  network: String!
  name: String!
  symbol: String!

  contractConfig: ContractConfig!

  salesConfig: SalesConfig!

  salesConfigHistory: [SalesConfig!]! @derivedFrom(field: "drop")

  sales: [NFTEditionSale!]! @derivedFrom(field: "drop")

  editionMetadata: EditionMetadata @derivedFrom(field: "drop")
  dropMetadata: DropMetadata @derivedFrom(field: "drop")

  roles: [DropRole!]! @derivedFrom(field: "drop")

  totalMinted: BigInt!
  maxSupply: BigInt!

  rendererAddress: Bytes!

  txn: TransactionInfo!
}

type ZoraCreate721Factory @entity {
  id: ID!

  implementation: Bytes!
  version: String!
  txn: TransactionInfo!
  dropMetadataRendererFactory: Bytes!
  editionMetadataRendererFactory: Bytes!
}

type DropRole @entity {
  # user-role
  id: ID!
  account: Bytes!
  sender: Bytes!
  roleHash: Bytes!
  role: String!
  updated: BigInt!
  granted: Boolean!

  drop: ERC721Drop!
}

type NFTEditionSale @entity {
  id: ID!
  pricePerToken: BigInt!
  priceTotal: BigInt!
  count: BigInt!
  purchaser: Bytes!
  firstPurchasedTokenId: Int!
  txn: TransactionInfo!
  mintedAt: BigInt!

  drop: ERC721Drop!
}

type Upgrade @entity {
  id: ID!
}

type EditionMetadata @entity {
  id: ID!

  drop: ERC721Drop
  description: String!
  imageURI: String!
  animationURI: String!
}

type DropMetadata @entity {
  id: ID!

  drop: ERC721Drop
  base: String!
  extension: String!
  freezeAt: BigInt!
  contractURI: String!
}

### ERC1155

# 1155 Records

type ZoraCreate1155Factory @entity {
  id: ID!
  txn: TransactionInfo!

  fixedPriceSaleStrategyAddress: Bytes!
  implementation: Bytes!
  merkleSaleStrategyAddress: Bytes!
  version: String!
}

type ZoraCreateContract @entity {
  id: ID!
  txn: TransactionInfo!

  address: Bytes!

  name: String
  symbol: String

  contractURI: String
  contractStandard: String!
  contractVersion: String
  metadata: MetadataInfo

  mintFeePerTxn: BigInt
  mintFeePerQuantity: BigInt!

  rendererContract: Bytes

  creator: Bytes!
  initialDefaultAdmin: Bytes
  owner: Bytes!

  tokens: [ZoraCreateToken!]! @derivedFrom(field: "contract")
  permissions: [ZoraCreatorPermission!]! @derivedFrom(field: "contract")
  royalties: RoyaltyConfig @derivedFrom(field: "contract")
  salesStrategies: [SalesStrategyConfig!]!
    @derivedFrom(field: "contract")

  createdAtBlock: BigInt!
}

type ZoraCreatorPermission @entity {
  id: ID!
  txn: TransactionInfo!

  user: Bytes!
  contract: ZoraCreateContract
  tokenAndContract: ZoraCreateToken

  tokenId: BigInt!

  isAdmin: Boolean!
  isMinter: Boolean!
  isSalesManager: Boolean!
  isMetadataManager: Boolean!
  isFundsManager: Boolean!
}

type ZoraCreateToken @entity {
  id: ID!
  txn: TransactionInfo!

  address: Bytes!

  uri: String
  totalSupply: BigInt!
  maxSupply: BigInt!
  totalMinted: BigInt!

  rendererContract: Bytes

  contract: ZoraCreateContract!
  tokenId: BigInt!
  tokenStandard: String!

  metadata: MetadataInfo

  onChainMetadataHistory: [OnChainMetadataHistory!]! @derivedFrom(field: "tokenAndContract")

  holders1155Number: BigInt!
  holders1155: [Token1155Holder!]! @derivedFrom(field: "tokenAndContract")

  permissions: [ZoraCreatorPermission!]!
    @derivedFrom(field: "tokenAndContract")
  royalties: [RoyaltyConfig!]! @derivedFrom(field: "tokenAndContract")
  salesStrategies: [SalesStrategyConfig!]!
    @derivedFrom(field: "tokenAndContract")
  createdAtBlock: BigInt!
}

type OnChainMetadataHistory @entity(immutable: true) {
  id: ID!
  txn: TransactionInfo!
  tokenAndContract: ZoraCreateToken!

  rendererAddress: Bytes!

  # history created at block
  createdAtBlock: BigInt!

  # 721-only edition metadata
  editionMetadata: EditionMetadata
  # 721-only drop metadata
  dropMetadata: DropMetadata

  # 1155 static uri
  uri: String
  # metadata info â€“ optional
  metadataInfo: MetadataInfo

  knownType: String!
}


type SalesConfigFixedPriceSaleStrategy @entity {
  id: ID!
  txn: TransactionInfo!

  configAddress: Bytes!

  tokenId: BigInt!
  contract: ZoraCreateContract!
  saleStart: BigInt!
  saleEnd: BigInt!
  maxTokensPerAddress: BigInt!
  pricePerToken: BigInt!

  fundsRecipient: Bytes
}

type SalesConfigMerkleMinterStrategy @entity {
  id: ID!
  txn: TransactionInfo!

  configAddress: Bytes!

  tokenId: BigInt!
  contract: ZoraCreateContract!
  presaleStart: BigInt!
  presaleEnd: BigInt!
  merkleRoot: Bytes!

  fundsRecipient: Bytes
}

type SalesStrategyConfig @entity {
  id: ID!
  txn: TransactionInfo!

  tokenAndContract: ZoraCreateToken
  contract: ZoraCreateContract

  presale: SalesConfigMerkleMinterStrategy
  fixedPrice: SalesConfigFixedPriceSaleStrategy
  type: String!
}

type MetadataInfo @entity {
  id: ID!
  name: String
  description: String
  image: String
  animationUrl: String
  decimals: String

  rawJson: String
}

type RoyaltyConfig @entity {
  id: ID!
  tokenId: BigInt!
  user: Bytes!
  royaltyBPS: BigInt!
  royaltyRecipient: Bytes!
  royaltyMintSchedule: BigInt!
  contract: ZoraCreateContract
  tokenAndContract: ZoraCreateToken
}

type Token1155Holder @entity {
  # id is (contract, token, user)
  id: ID!
  user: Bytes!
  lastUpdatedBlock: BigInt!
  tokenAndContract: ZoraCreateToken!
  balance: BigInt!
}